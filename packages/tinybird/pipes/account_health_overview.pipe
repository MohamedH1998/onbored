TOKEN read READ

DESCRIPTION >
  Account Health Overview: aggregate counts by risk tier.
  Used for dashboard "war room" view.

  This pipe duplicates the health score calculation logic from account_health_score.pipe
  to avoid pipe-to-pipe calls which Tinybird doesn't support well.

NODE account_cross_funnel_metrics
SQL >
  %
  WITH valid_flows AS (
    SELECT
      flow_id,
      min(timestamp) as first_event,
      max(timestamp) as last_event
    FROM events
    WHERE
      project_key = {{ String(project_key) }}
      AND event_type IN ('step_viewed', 'step_completed', 'step_abandoned')
      AND account_id != 'UNKNOWN'
      AND account_id != ''
      AND timestamp >= toDateTime64({{ DateTime(start_date) }}, 3)
      AND timestamp <= toDateTime64({{ DateTime(end_date) }}, 3)
    GROUP BY flow_id
    HAVING count(*) > 1 AND dateDiff('second', first_event, last_event) >= 1
  )
  SELECT
    e.account_id,
    count(DISTINCT e.funnel_slug) AS total_funnels,
    count(DISTINCT CASE WHEN v.flow_id IS NOT NULL THEN e.flow_id END) AS total_flows_started,
    count(DISTINCT CASE WHEN e.event_type = 'flow_completed' AND v.flow_id IS NOT NULL THEN e.flow_id END) AS total_flows_completed,
    CASE
      WHEN total_flows_started > 0
      THEN round((total_flows_completed / total_flows_started) * 100, 2)
      ELSE 0
    END AS cross_funnel_completion_rate
  FROM events e
  LEFT JOIN valid_flows v ON e.flow_id = v.flow_id
  WHERE
    e.project_key = {{ String(project_key) }}
    AND e.account_id != 'UNKNOWN'
    AND e.account_id != ''
    AND e.timestamp >= toDateTime64({{ DateTime(start_date) }}, 3)
    AND e.timestamp <= toDateTime64({{ DateTime(end_date) }}, 3)
  GROUP BY e.account_id

NODE account_engagement_velocity
SQL >
  %
  WITH
    current_period AS (
      SELECT
        account_id,
        count(*) AS current_event_count
      FROM events
      WHERE
        project_key = {{ String(project_key) }}
        AND account_id != 'UNKNOWN'
        AND account_id != ''
        AND timestamp >= toDateTime64({{ DateTime(start_date) }}, 3)
        AND timestamp <= toDateTime64({{ DateTime(end_date) }}, 3)
      GROUP BY account_id
    ),
    prior_period AS (
      SELECT
        account_id,
        count(*) AS prior_event_count
      FROM events
      WHERE
        project_key = {{ String(project_key) }}
        AND account_id != 'UNKNOWN'
        AND account_id != ''
        AND timestamp >= toDateTime64({{ DateTime(start_date) }}, 3) - INTERVAL 7 DAY
        AND timestamp < toDateTime64({{ DateTime(start_date) }}, 3)
      GROUP BY account_id
    )
  SELECT
    COALESCE(c.account_id, p.account_id) AS account_id,
    COALESCE(c.current_event_count, 0) AS current_event_count,
    COALESCE(p.prior_event_count, 0) AS prior_event_count,
    CASE
      WHEN prior_event_count > 0
      THEN round(((current_event_count - prior_event_count) / prior_event_count) * 100, 2)
      WHEN current_event_count > 0
      THEN 100
      ELSE 0
    END AS velocity_change_pct
  FROM current_period c
  FULL OUTER JOIN prior_period p
    ON c.account_id = p.account_id

NODE account_recency
SQL >
  %
  SELECT
    account_id,
    max(timestamp) AS last_activity_at,
    dateDiff('day', max(timestamp), now()) AS days_since_last_activity
  FROM events
  WHERE
    project_key = {{ String(project_key) }}
    AND account_id != 'UNKNOWN'
    AND account_id != ''
    AND timestamp >= toDateTime64({{ DateTime(start_date) }}, 3) - INTERVAL 30 DAY
    AND timestamp <= toDateTime64({{ DateTime(end_date) }}, 3)
  GROUP BY account_id

NODE account_failed_sessions
SQL >
  %
  WITH
    valid_flows AS (
      SELECT
        flow_id,
        min(timestamp) as first_event,
        max(timestamp) as last_event
      FROM events
      WHERE
        project_key = {{ String(project_key) }}
        AND event_type IN ('step_viewed', 'step_completed', 'step_abandoned')
        AND account_id != 'UNKNOWN'
        AND account_id != ''
        AND timestamp >= toDateTime64({{ DateTime(start_date) }}, 3)
        AND timestamp <= toDateTime64({{ DateTime(end_date) }}, 3)
      GROUP BY flow_id
      HAVING count(*) > 1 AND dateDiff('second', first_event, last_event) >= 1
    ),
    session_outcomes AS (
      SELECT
        e.account_id,
        e.session_id,
        max(CASE WHEN e.event_type = 'flow_completed' THEN 1 ELSE 0 END) AS completed,
        max(CASE WHEN e.event_type = 'flow_started' AND v.flow_id IS NOT NULL THEN 1 ELSE 0 END) AS started
      FROM events e
      LEFT JOIN valid_flows v ON e.flow_id = v.flow_id
      WHERE
        e.project_key = {{ String(project_key) }}
        AND e.account_id != 'UNKNOWN'
        AND e.account_id != ''
        AND e.timestamp >= toDateTime64({{ DateTime(start_date) }}, 3)
        AND e.timestamp <= toDateTime64({{ DateTime(end_date) }}, 3)
      GROUP BY e.account_id, e.session_id
    )
  SELECT
    account_id,
    count(*) AS total_sessions,
    countIf(started = 1 AND completed = 0) AS failed_sessions,
    CASE
      WHEN total_sessions > 0
      THEN round((failed_sessions / total_sessions) * 100, 2)
      ELSE 0
    END AS failed_session_ratio_pct
  FROM session_outcomes
  GROUP BY account_id

NODE account_health_scores
SQL >
  %
  SELECT
    cfm.account_id,

    -- Score components
    round(cfm.cross_funnel_completion_rate * 0.4, 2) AS completion_score,

    -- Base velocity score with quality adjustment
    round(
      CASE
        WHEN ev.velocity_change_pct >= 50 THEN 30
        WHEN ev.velocity_change_pct >= 0 THEN 15 + (ev.velocity_change_pct / 50 * 15)
        ELSE greatest(0, 15 + (ev.velocity_change_pct / 100 * 15))
      END * ((100 - fs.failed_session_ratio_pct) / 100),
      2
    ) AS velocity_score,

    CASE
      WHEN r.days_since_last_activity <= 1 THEN 20
      WHEN r.days_since_last_activity <= 7 THEN 15
      WHEN r.days_since_last_activity <= 14 THEN 10
      WHEN r.days_since_last_activity <= 30 THEN 5
      ELSE 0
    END AS recency_score,

    round((100 - fs.failed_session_ratio_pct) * 0.1, 2) AS session_success_score,

    -- Final health score
    round(
      completion_score + velocity_score + recency_score + session_success_score,
      0
    ) AS health_score,

    -- Risk tier
    CASE
      WHEN health_score >= 71 THEN 'healthy'
      WHEN health_score >= 41 THEN 'at_risk'
      ELSE 'critical'
    END AS risk_tier

  FROM account_cross_funnel_metrics cfm
  LEFT JOIN account_engagement_velocity ev
    ON cfm.account_id = ev.account_id
  LEFT JOIN account_recency r
    ON cfm.account_id = r.account_id
  LEFT JOIN account_failed_sessions fs
    ON cfm.account_id = fs.account_id

NODE account_risk_counts
DESCRIPTION >
  Aggregate counts by risk tier.
SQL >
  %
  SELECT
    countIf(risk_tier = 'critical') AS critical_count,
    countIf(risk_tier = 'at_risk') AS at_risk_count,
    countIf(risk_tier = 'healthy') AS healthy_count,
    count(*) AS total_accounts
  FROM account_health_scores

TYPE ENDPOINT
